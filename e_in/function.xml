<?xml version="1.0" encoding="UTF-8" ?>
<doc>
<title>function</title>

<para>
<ptitle>function</ptitle>
　TJS2 functions are almost the same as <kw>subroutine</kw>. A function that does not return a value is treated as a function.<r/>
　In particular, functions that are members of classes and objects are sometimes called "<kw>methods</kw>".<r/>
</para>

<para>
<ptitle>How to write functions</ptitle>
　Functions can be written in the following format:<r/>
<bq>
	function function_name ( argument_list )<r/>
	{<r/>
		function_contents<r/>
	}<r/>
</bq>
<r/>
　First, to define the function, write <kw>function</kw>. After that, write the name of the function. The function can be used with the name written here.<r/>
　In the contents of the function, you can describe statements or blocks that you want to execute in the function.<r/>
<r/>
<example>
	function test(a) { System.inform(a); }<r/>
	function func(a, b, c, d)<r/>
	{<r/>
		test(a);<r/>
		test(b);<r/>
		test(c);<r/>
		test(d);<r/>
		return a+b-c*d;<r/>
	}<r/>
</example>
<r/>
True if you use the instanceof operator on a function with "Function" (in the example above, func instanceof "Function" is true).<r/>
</para>

<para>
<ptitle>Function call</ptitle>
　Function calls are written as follows using the <kw>( )</kw> operator.<r/>
<tt>
	function_name(arguments)<r/>
</tt>
	If there is no argument, it will be <tt>function_name()</tt>. For the argument, specify an expression. If there is more than one, specify them by separating them with commas.<r/>
<example>
	func();<r/>
	func(1+2, 1-2);<r/>
	func(func2());<r/>
</example>
<r/>
	Also, if you leave it empty without specifying an expression, it is assumed that void is specified in that part.<r/>
<example>
	func(,1); // void, 1 is assumed to be specified<r/>
	func(,); // void, void is assumed to be specified<r/>
</example>
</para>

<para>
<ptitle>Argument list</ptitle>
　In the argument list, write the name of the variable to receive the passed argument. Of the arguments passed at the time of the function call, they are passed to the variables in order from the one written before.<r/>
<example>
	function test(a, b, c)<r/>
	{<r/>
		// At this point, the variables a, b, and c are available, with the three arguments passed as arguments. When you call test (1, 2, 3), a contains 1 and b contains 2, and c contains 3.<r/>
	}<r/>
</example>
<r/>
　These arguments are local variables and will not be accessible once execution exits the function.<r/>
<r/>
　In TJS2, it is not an error if the number of arguments given in a function call is less or more than the number of arguments in the declaration (except for functions that are not written in TJS2 ( Function written in C ++, etc.) may cause an error.) If more arguments are given than declarations, more will be ignored; otherwise, void will be passed to the missing variables.<r/>
<example>
	function test(a, b)<r/>
	{<r/>
		// If called as test (1), a will contain 1 and b will contain void.<r/>
		// If called as test (1,2,3), a is 1 and b is 2; 3 is ignored<r/>
	}<r/>
</example>
<r/>
　Each argument in the argument list can have a default value (<kw>default argument</kw>) following the =. This means that if void is specified or if the given argument is less than the argument in the declaration, the specified value will be used automatically.<r/>
<example>
	function test(a = -1, b = 1)<r/>
	{<r/>
		// if...<r/>
		// When called as test (), a = -1, b = 1<r/>
		// When called as test (5), a = 5, b = 1<r/>
		// When called as test (void, void), a = -1, b = 1<r/>
		// When called as test (, 4), a = -1, b = 4<r/>
	}<r/>
</example>
<r/>
　Functions that do not need to accept arguments can omit the argument list.<r/>
<example>
	function test<r/>
	{<r/>
		// Functions that do not accept arguments<r/>
	}<r/>
</example>
</para>

<para>
<ptitle>Function in expression</ptitle>
　The function keyword can be used in expressions to create unnamed functions, functions in expressions (<kw>anonymous functions</kw>).<r/>
　In this case, omit the function name.<r/>
<example>
	var func = function(i) { return i*5; };<r/>
	var func2 = function { System.inform("hoge"); };<r/>
	var v = func(); // func call<r/>
	func2(); // func2 call<r/>
</example>
</para>

<para>
<ptitle>Omitting arguments</ptitle>
　If you write only <kw>...</kw> as arguments when calling a function, the arguments passed to the function that describes the expression to be called will be passed to the function that called the function. This means that even if you have changed the contents of the argument variables, or if you have not received enough arguments, you will know the correct original contents and the number of arguments.<r/>
<example>
	function test()<r/>
	{<r/>
		test2(...);<r/>
		// test2 is passed the arguments passed to test with the exact content and number of arguments passed<r/>
	}<r/>
</example>
</para>

<para>
<ptitle>Array conversion of arguments</ptitle>
　Arguments can be received as an array. To receive as an array, declare the function with '<kw>*</kw>' in the argument name.<r/>
<example>
	function func(args*)<r/>
	{<r/>
		// args will be an array with the arguments passed to this function as elements. For example, if called as func (1, 2, 3, 4), args will contain 4 elements and 1 2 3 4 Will be in the order of.<r/>
	}<r/>
</example>
<r/>
　You can also receive everything from the middle to the end of the argument as an array. The array will be empty if there are not enough arguments.<r/>
<example>
	function func(x, args*)<r/>
	{<r/>
		// For example, when called as func (1, 2, 3, 4), x contains 1. Also, args contains three elements, and the numbers are in the order of 2 3 4 from the top. When called as func (1), args is an array with no elements because there are fewer arguments.<r/>
	}<r/>
</example>
　This is useful if you want to handle variable length arguments.<r/>
<r/>
　It is also possible not to specify the argument name. In this case, it can be used as an unnamed * when expanding to an array argument described below.<r/>
</para>

<para>
<ptitle>Expand array into arguments</ptitle>
　You can expand the array and pass it as an argument to the function. In this case, call the function with '<kw>*</kw>' after the expression you want to expand, as in the case of argument array expansion. The expression you want to expand with '*' must represent an array.<r/>
<example>
	var args = [1, 2, 3, 4];<r/>
	func(args*);<r/>
	// Since args contains 4 elements of 1 2 3 4, it has the same meaning as func (1, 2, 3, 4);<r/>
	func(0, args*, 5);<r/>
	// In this way, it is possible to put it in the middle of the argument.<r/>
	// In this case, it has the same meaning as func (0, 1, 2, 3, 4, 5);<r/>
</example>
<r/>
　By simply specifying * as an argument without specifying an expression, the argument represented by the unnamed '*' written when declaring the function that describes the expression to be called can be passed to the callee as it is.
<example>
	function func(func_array, *)<r/>
	{<r/>
		// Calls the function specified by func_array, passing the second and subsequent arguments passed to func as is, following the function's position in func_array<r/>
		for(var i = 0; i &lt; func_array.count; i++)<r/>
			func_array[i](i, *);<r/>
	}<r/>
</example>
<r/>
　Function call processing with an unnamed * is more efficient than using a named array.<r/>
<example>
	function func(ar*) { func2(ar*); }<r/>
	function func(*) { func2(*); }<r/>
	// The above two have exactly the same meaning, but the example below is more efficient<r/>
</example>
<r/>
　An unnamed * has the same effect as "argument omission". The following two function declarations have the same meaning.<r/>
<example>
	function func() { func2(...); }<r/>
	function func(*) { func2(*); }<r/>
</example>
</para>

</doc>
