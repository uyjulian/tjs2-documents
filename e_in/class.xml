<?xml version="1.0" encoding="UTF-8" ?>
<doc>
<title>Class</title>

<para>
<ptitle>Class</ptitle>
　Classes are a template for creating objects. Variables belonging to a class are called member variables, functions belonging to a class are called member functions or methods, and properties belonging to a class are called member properties.<r/>
<r/>
　Classes are basically declared as follows:<r/>
<bq>
<kw>class</kw> classname<r/>
{<r/>
	// Describe members, member methods and member properties<r/>
<r/>
	function classname() // constructor<r/>
	{<r/>
	}<r/>
<r/>
	function <kw>finalize</kw>()<r/>
	{<r/>
	}<r/>
}<r/>
<r/>
</bq>
<r/>
　Specify an identifier for the class name.<r/>
<r/>
　In the class, describe the variables, methods, and properties that become members when the class is created.<r/>
<r/>
　There is always one method in the class with the same name as the class, called the <kw>constructor</kw>. This means that when you create an object using the <kw>new</kw> operator, this function will be called with the argument of the new operator.<r/>
<r/>
　Similarly, there is a special method in the class called finalize. This is an optional method that will be called when the object disappears. You do not need to write it.<r/>
<r/>
<example>
	class test<r/>
	{<r/>
		function test()<r/>
		{<r/>
			// constructor<r/>
			// Write here what to do when the object is created<r/>
			variable = 0;<r/>
		}<r/>
<r/>
		function finalize()<r/>
		{<r/>
			// finalize method<r/>
			// Write here what to do when the object is destroyed<r/>
		}<r/>
<r/>
		function method1()<r/>
		{<r/>
			// Method<r/>
			System.inform(variable);<r/>
		}<r/>
<r/>
		var variable; // Member variable<r/>
<r/>
		property prop // Member properties<r/>
		{<r/>
			getter() { return variable; } <r/>
		}<r/>
	}<r/>
</example>
<r/>
True if you use the instanceof operator on a class with "Class" (in the example above, test instanceof "Class" is true).<r/>

</para>

<para>
<ptitle>Creating objects</ptitle>
　Use the new operator to create an object of the declared class.<r/>
　After the new operator, specify the class name and the arguments to be passed to the constructor, as in the function call.<r/>
<example>
	class Test<r/>
	{<r/>
		var variable1 = getValue(); // Initialization of member variables<r/>
<r/>
		function Test(arg1, arg2) // constructor<r/>
		{<r/>
			// Here the argument specified by the new operator extends over arg1 and arg2<r/>
		}<r/>
	}<r/>
<r/>
	var newobject = new Test(1, 2); // Create test class object by passing 1 and 2 as arguments<r/>
</example>
<r/>
　The order of processing when a class is created is as follows.<r/>
<r/>
<ol>
<li>First an empty object is created</li>
<li>Method and property are registered</li>
<li>Member variables are created (at this time, variables that need to be initialized are initialized)</li>
<li>The constructor is executed</li>
</ol>

<note>
　Even if there are no arguments to the constructor, you cannot omit the ( ) of the new operator. You cannot write new Test like JavaScript. You need to write new Test ( ).<r/>
</note>

<r/>
　In particular, if you create an object of that class in a method or property of a class, or create an object of a superclass of that class, you will get an error if you do the following:<r/>
<example>
	class Test<r/>
	{<r/>
		function Test() // constructor<r/>
		{<r/>
		}<r/>
<r/>
		function func()<r/>
		{<r/>
			return new Test(); // error<r/>
		}<r/>
	}<r/>
</example>
<r/>
　This is because if you simply write Test in a class method or property, the constructor Test will be referred to in the constructor Test because the Test of its constructor is closer in scope than the class Test. To avoid this, you must explicitly use global. (Because the class is registered with global) as follows:<r/>
<r/>
<example>
	class Test<r/>
	{<r/>
		function Test() // constructor<r/>
		{<r/>
		}<r/>
<r/>
		function func()<r/>
		{<r/>
			return new global.Test(); // If this is OK<r/>
		}<r/>
	}<r/>
</example>
</para>

<para>
<ptitle>Invalidating objects</ptitle>
　In TJS2, when an object is deleted, there are two stages: <kw>invalidating</kw> the object and deleting the object.<r/>
　When an object is invalidated, the finalize method is called and the object is marked invalid. All subsequent access to the object will fail, causing an exception to be raised. You can check if an object has been invalidated with the <kw>isvalid</kw> operator.<r/>
<r/>
　Objects can be invalidated with the <kw>invalidate</kw> operator.<r/>
<r/>
<example>
	class Test<r/>
	{<r/>
		var variable;<r/>
<r/>
		function Test()<r/>
		{<r/>
			// constructor<r/>
			variable = new AnotherClass();<r/>
		}<r/>
<r/>
		function finalize()<r/>
		{<r/>
			// finalize method is called when invalidated<r/>
			invalidate variable;<r/>
		}<r/>
	}<r/>
<r/>
	var object = new Test(); // Create object<r/>
<r/>
	(Omitted)<r/>
<r/>
	invalidate object; // Invalidate object<r/>
</example>
<r/>
　Even without using the invalidate operator, objects are deleted when they are no longer needed. At this time, if it has not been invalidated, it will be invalidated at that time.<r/>
　In TJS2 there is no clear rule for when an object is deleted, and deletion or invalidation is "always possible". Therefore, objects that have not been invalidated will be invalidated on deletion, and the finalize method may be called at an unexpected time. To avoid this, we recommend that you use the invalidate operator to invalidate objects when you are finished using them.<r/>
<r/>
<note>
　The invalidate operator works much like the C ++ delete operator.<r/>
　Unlike the C ++ delete operator, the delete operator in TJS2 is for deleting members and local variables. It does not invalidate or delete the object itself, but deleting a member or local variable can cause the object to be invalidated or deleted.<r/>
</note>
</para>

<para>
<ptitle>Accessing objects</ptitle>
　Access the member variables, methods, and member properties of the created object using the <kw>.</kw> (member selection) operator or <kw>[ ]</kw> (indirect member selection operator). You.<r/>
<example>
	var obj=new MyLayer(window,window.prmaryLayer)<r/>
	obj.method1(); // Same for method invocation obj['method1']()<r/>
	obj.num = 3; // Assignment to member variables is the same even if obj['num']=3<r/>
	obj.prop1++; // Access member properties Same for obj['prop1']++<r/>
</example>
</para>

<para>
<ptitle>closure</ptitle>
　The methods and member properties of the created object are registered in the object with information on which object the member is a member of.<r/>
　Therefore, even if you take a method or member property out of the object and use it, you still have access to the original object. This function is called closure. The object to be accessed is called <kw>context</kw>.<r/>
<example>
	var obj = new FooBarClass(); // Create object<r/>
	obj.method(); // Call object methods normally<r/>
	var objmethod = obj.method; // Assign reference to object method to objmethod<r/>
	objmethod(); // Call objmethod, but access to obj as in obj.method ()<r/>
</example>
<r/>
　The <kw>incontextof</kw> operator changes the information about which objects are members and provides a way to execute a method in any context.<r/>
<example>
	(objmethod incontextof obj2)(); // Become an operation on obj2<r/>
	(objmethod incontextof this)(); // Become an operation on this
</example>

</para>


<para>
<ptitle>Inheritance</ptitle>
　The keyword <kw>extends</kw> allows a class to inherit from another class. Inheritance means inheriting the members of the class from which you inherited.<r/>
　The class that inherits is called <kw>superclass</kw>, and the inherited class is called <kw>subclass</kw>.<r/>
　Declare the class as follows:<r/>
<example>
	class Class1 // Super class<r/>
	{<r/>
		function Class1() // Class1 constructor<r/>
		{<r/>
		}<r/>
<r/>
		function finalize() // Class1 finalize<r/>
		{<r/>
		}<r/>
<r/>
		function method1() // method1<r/>
		{<r/>
		}<r/>
	}<r/>
<r/>
<r/>
	class Class2 extends Class1<r/>
	{<r/>
		function Class2() // Class2 constructor<r/>
		{<r/>
			super.Class1(); // Call the Class1 constructor<r/>
		}<r/>
<r/>
		function finalize() // Class2 finalize<r/>
		{<r/>
			super.finalize();<r/>
		}<r/>
	}<r/>
<r/>
	var obj = new Class2(); // Create Class2 object<r/>
	obj.method1(); // Class2 can be used because it inherits method1 of Class1<r/>
</example>
　In the example above, Class2 inherits from Class1. Class2 is also said to be <kw>derived</kw> from Class1.<r/>
　The constructor of Class2 calls the constructor of Class1 and the finalize of Class2 calls the finalize of Class1. <b>The behavior when the subclass does not call the corresponding method of the superclass in these methods is undefined</b> (or in the current version, it is not checked whether it is called), so be sure to please write it.<r/>
<r/>
　To reference a superclass from a subclass, you can use the keyword <kw>super</kw> as in the example above. This keyword can only be used within a subclass and represents a superclass.<r/>
<r/>
　The order of initialization of objects with the new operator when inheritance is performed is as follows.<r/>
<r/>
<ol>
<li>First an empty object is created</li>
<li>Methods and properties are registered (from superclass to subclass)</li>
<li>Member variables are created (superclass first, subclass)</li>
<li>Subclass constructor is called</li>
<li>The superclass constructor is called (from within the subclass constructor)</li>
</ol>
</para>

<para>
<ptitle>Multiple inheritance</ptitle>
　Multiple inheritance can be performed by describing multiple super class names after extends.<r/>
<example>
	class SubClass extends ClassA, ClassB<r/>
	{<r/>
		function SubClass() // SubClass constructor<r/>
		{<r/>
			ClassA(); // Call the ClassA constructor<r/>
			ClassB(); // Call the ClassB constructor<r/>
		}<r/>
<r/>
		function finalize() // Class2 finalize<r/>
		{<r/>
			global.ClassA.finalize();<r/>
			global.ClassB.finalize();<r/>
		}<r/>
	}<r/>
<r/>
</example>
　Since the super keyword cannot be used, the class must be explicitly specified. When calling the method of the super class as in the example, the reason for accessing the class by deliberately adding global. Is that simply writing ClassA in the subclass refers to the constructor of ClassA. Since the class itself is registered in global, access the class using global.<r/>
<r/>
　When multiple inheritance is performed, the order of initializing objects with the new operator is the same as when multiple inheritance is not performed, but the order of registration of superclass methods and properties is determined by the It is done in the order written later. If there is a method or property with the same name between the inheriting classes, the one written later has priority. Hidden methods and properties can be accessed by explicitly writing the class name like global.ClassA.hiddenMethod ().<r/>
</para>

<para>
<ptitle>override</ptitle>
　By declaring a subclass with the same name as a superclass method or member property, you can hide the superclass method. This is called an override.<r/>
　The finalize method in the above description overrides the finalize method of the superclass.<r/>
<example>
	class Class1 // Super class<r/>
	{<r/>
		function Class1() // Class1 constructor<r/>
		{<r/>
		}<r/>
<r/>
		function finalize() // Class1 finalize<r/>
		{<r/>
		}<r/>
<r/>
		function method1() // method1<r/>
		{<r/>
			(omitted)<r/>
		}<r/>
	}<r/>
<r/>
<r/>
	class Class2 extends Class1<r/>
	{<r/>
		function Class2() // Class2 constructor<r/>
		{<r/>
			super.Class1(); // Call the Class1 constructor<r/>
		}<r/>
<r/>
		function finalize() // Class2 finalize<r/>
		{<r/>
			super.finalize();<r/>
		}<r/>
<r/>
		function method1() // Override Class1.method1<r/>
		{<r/>
			(omitted)<r/>
			if(omitted) return super.method1();<r/>
			(omitted)<r/>
		}<r/>
	}<r/>
<r/>
	var obj = new Class2(); // Create Class2 object<r/>
	obj.method1(); // Class1 method1 is called<r/>
</example>
　Subclass methods and properties can be accessed using the super keyword.<r/>
<r/>
　Member variables cannot be overridden. Because member variables are registered for one object, if there is a member function with the same name in the subclass and superclass Subclass variables overwrite superclass variables.<r/>
</para>

</doc>
