<?xml version="1.0" encoding="UTF-8" ?>
<doc>
<title>Virtual machine</title>

<para>
<ptitle>TJS2 VM</ptitle>
　TJS2 compiles the script into binary code for the virtual machine (TJS2 <kw>VM</kw>) and then executes it.<r/>
　A brief description of this virtual machine is provided, as the disassembly result of this TJS2 VM code is displayed when an exception occurs or when a dump is taken.<r/>
</para>

<para>
<ptitle>Instruction code</ptitle>
　The TJS2 VM is independent for each execution unit such as functions and properties, and one function does not share the instruction code space, register space, flags, and constant area with other functions.<r/>
　The instruction pointer (ip) always starts from 0 at the head of a function or the like.<r/>
　A mnemonic is a simple human-readable name for an instruction code.
</para>

<para>
<ptitle>register</ptitle>
　TJS2 VM registers are represented by% (number) in the mnemonic. Numbers can be negative. There is no limit on the number of registers. All local variables and temporary values during calculation are recorded in registers. There is no main memory or stack.<r/>
　The values represented by the registers are the same as so-called variables in TJS2, and can represent integers, real numbers, objects, strings, octets, and voids.<r/>
　In the current version, register% 0 is always void. Register% -1 becomes this. Register% -2 is a special object called <kw>this proxy</kw>. When a member reference is made to this object, the operation that looks at this first, and if not there, goes to global. To do. this proxy does not exist in the global level execution unit. The execution of the function and other arguments is started in a state where they are stored in advance in registers such as% -3 and% -4.<r/>
　The values of registers other than those whose uses are predetermined or whose values are stored before execution are undefined at the start of execution.<r/>
</para>

<para>
<ptitle>flag</ptitle>
　The TJS2 VM has only one flag and stores the comparison result. Flags take only true or false values.<r/>
</para>

<para>
<ptitle>Constant area</ptitle>
　The constant area of the TJS2 VM is a place to store constants, and is represented by * (number) in the mnemonic. The constant area is read-only, and the const instruction is used to transfer the value of this constant area to the register. In addition, the "name" for accessing the member of the object by name, such as function name and property name, is also stored in this constant area.<r/>
</para>

<para>
<ptitle>VM mnemonic list</ptitle>
　Some operands have the form <tt>%obj.*name</tt> or <tt>%obj.%name</tt>, but these involve object member references.<r/>
　Operands that have the form <tt>%obj.*name</tt> are direct references, and the object represented by the register <tt>%obj</tt>  refers to the member whose name is represented by <tt>*name</tt>.<r/>
　Operands that have the form <tt>%obj.%name</tt> perform indirect references, and use the register from the object represented by the register <tt>%obj</tt>, refers to the member whose name is represented by <tt>%name</tt>.<r/>
　The mnemonics for such instructions have the suffix d or pd (direct / property direct) or i or pi (indirect / property indirect).<r/>
　Anything with a suffix of p runs the property handler for the target register (works for the unary '*' operator).<r/>
<r/>
<r/>
<dl>

<dt><kw>nop</kw><r/>(no operation)</dt>
<dd>
　Do nothing.
</dd>


<dt><kw>const</kw><r/>(copy constant value)</dt>
<dd>
Format: <tt>const %dest, *src</tt><r/><r/>
　Copy the value of the constant area indicated by *src to the register indicated by %dest.
</dd>


<dt><kw>cp</kw><r/>(copy register)</dt>
<dd>
Format: <tt>cp %dest, %src</tt><r/><r/>
　Copies the value of the register pointed to by %src to the register pointed to by %dest.
</dd>


<dt><kw>cl</kw><r/>(clear register)</dt>
<dd>
Format: <tt>cl %dest</tt><r/><r/>
　Makes the register indicated by %dest void.
</dd>


<dt><kw>ccl</kw><r/>(clear register)</dt>
<dd>
Format: <tt>ccl %low-%high</tt><r/><r/>
　Makes all registers from %low to %high void.
</dd>


<dt><kw>tt</kw><r/>(test true)</dt>
<dd>
Format: <tt>tt %reg</tt><r/><r/>
　Sets the flag to true if the register indicated by %reg indicates true, and sets the flag to false if it indicates false.
</dd>


<dt><kw>tf</kw><r/>(test false)</dt>
<dd>
Format: <tt>tf %reg</tt><r/><r/>
　Conversely to tt, set the flag to false if the register pointed to by %reg indicates true, and set the flag to true if it indicates false.
</dd>


<dt><kw>ceq</kw><r/>(compare equal)</dt>
<dd>
Format: <tt>ceq %reg1, %reg2</tt><r/><r/>
　Set the flag to true if %reg1 and %reg2 match in a normal comparison (the behavior of the == operator), otherwise false.
</dd>


<dt><kw>cdeq</kw><r/>(compare distinct equal)</dt>
<dd>
Format: <tt>cdeq %reg1, %reg2</tt><r/><r/>
　Set the flag to true if %reg1 and %reg2 match in an identity comparison (the behavior of the === operator), otherwise set the flag to false.
</dd>


<dt><kw>clt</kw><r/>(compare littler than)</dt>
<dd>
Format: <tt>clt %reg1, %reg2</tt><r/><r/>
　Set the flag to true if %reg1 &gt; %reg2, false otherwise.
</dd>


<dt><kw>cgt</kw><r/>(compare greater than)</dt>
<dd>
Format: <tt>cgt %reg1, %reg2</tt><r/><r/>
　Set the flag to true if %reg1 &lt; %reg2, false otherwise.
</dd>


<dt><kw>setf</kw><r/>(set flag)</dt>
<dd>
Format: <tt>setf %dest</tt><r/><r/>
　Set %dest to true (integer non-zero) if flag is true, false (integer 0) if false.
</dd>


<dt><kw>setnf</kw><r/>(set not flag)</dt>
<dd>
Format: <tt>setnf %dest</tt><r/><r/>
　Conversely to setf, sets %dest to true (integer 0) if flag is false, false (integer 0) if true.
</dd>


<dt><kw>lnot</kw><r/>(logical not)</dt>
<dd>
Format: <tt>lnot %reg</tt><r/><r/>
　Reverses the truth of %reg.
</dd>


<dt><kw>nf</kw><r/>(not flag)</dt>
<dd>
Format: <tt>nf</tt><r/><r/>
　Reverse the truth of the flag.
</dd>


<dt><kw>jf</kw><r/>(jump if flag)</dt>
<dd>
Format: <tt>jf ip</tt><r/><r/>
　If the flag is true, jump to ip.
</dd>


<dt><kw>jnf</kw><r/>(jump if not flag)</dt>
<dd>
Format: <tt>jnf ip</tt><r/><r/>
　If the flag is false, jump to ip.
</dd>


<dt><kw>inc</kw>, <kw>incpd</kw>, <kw>incpi</kw>, <kw>incp</kw><r/>(increment)</dt>
<dd>
Format: <tt>inc %reg</tt><r/>
Format: <tt>incpd %res, %obj.*name</tt><r/>
Format: <tt>incpi %res, %obj.%name</tt><r/>
Format: <tt>incp %res, %propobj</tt><r/>
<r/>
　Increments %reg or %obj.*name or %obj.%name or %propobj.<r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>dec</kw>, <kw>decpd</kw>, <kw>decpi</kw>, <kw>decp</kw><r/>(decrement)</dt>
<dd>
Format: <tt>dec %reg</tt><r/>
Format: <tt>decpd %res, %obj.*name</tt><r/>
Format: <tt>decpi %res, %obj.%name</tt><r/>
Format: <tt>decp %res, %propobj</tt><r/>
<r/>
　Decrement %reg or %obj.*name or %obj.%name or %propobj.<r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>lor</kw>, <kw>lorpd</kw>, <kw>lorpi</kw>, <kw>lorp</kw><r/>(logical or)</dt>
<dd>
Format: <tt>lor %dest, %src</tt><r/><r/>
　Performs a logical OR of %dest and %src and stores the result in %dest.<r/><r/>
Format: <tt>lorpd %res, %obj.*name, %src</tt><r/><r/>
　Performs a logical OR of %obj.*name and %src and stores the result in %obj.*name.<r/><r/>
Format: <tt>lorpi %res, %obj.%name, %src</tt><r/><r/>
　Performs a logical OR of %obj.%name and %src and stores the result in %obj.%name.<r/><r/>
Format: <tt>lorp %res, %propobj, %src</tt><r/><r/>
　Performs a logical OR of %propobj and %src and stores the result in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>land</kw>, <kw>landpd</kw>, <kw>landpi</kw>, <kw>landp</kw><r/>(logical and)</dt>
<dd>
Format: <tt>land %dest, %src</tt><r/><r/>
　Performs a logical AND of %dest and %src and stores the result in %dest.<r/><r/>
Format: <tt>landpd %res, %obj.*name, %src</tt><r/><r/>
　Performs a logical AND of %obj.*name and %src and stores the result in %obj.*name.<r/><r/>
Format: <tt>landpi %res, %obj.%name, %src</tt><r/><r/>
　Performs a logical AND of %obj.%name and %src and stores the result in %obj.%name.<r/><r/>
Format: <tt>landp %res, %propobj, %src</tt><r/><r/>
　Performs a logical AND of %propobj and %src and stores the result in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>bor</kw>, <kw>borpd</kw>, <kw>borpi</kw>, <kw>borp</kw><r/>(bitwise or)</dt>
<dd>
Format: <tt>bor %dest, %src</tt><r/><r/>
　Performs a bitwise OR of %dest and %src and stores the result in %dest.<r/><r/>
Format: <tt>borpd %res, %obj.*name, %src</tt><r/><r/>
　Performs a bitwise OR of %obj.*name and %src and stores the result in %obj.*name.<r/><r/>
Format: <tt>borpi %res, %obj.%name, %src</tt><r/><r/>
　Performs a bitwise OR of %obj.%name and %src and stores the result in %obj.%name.<r/><r/>
Format: <tt>borp %res, %propobj, %src</tt><r/><r/>
　Performs a bitwise OR of %propobj and %src and stores the result in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>bxor</kw>, <kw>bxorpd</kw>, <kw>bxorpi</kw>, <kw>bxorp</kw><r/>(bitwise xor)</dt>
<dd>
Format: <tt>bxor %dest, %src</tt><r/><r/>
　Performs a bitwise exclusive OR of %dest and %src and stores the result in %dest.<r/><r/>
Format: <tt>bxorpd %res, %obj.*name, %src</tt><r/><r/>
　Performs a bitwise exclusive OR of %obj.* name and %src and stores the result in %obj.*name.<r/><r/>
Format: <tt>bxorpi %res, %obj.%name, %src</tt><r/><r/>
　Performs a bitwise exclusive OR of %obj.%name and% src and stores the result in %obj.%name.<r/><r/>
Format: <tt>bxorp %res, %propobj, %src</tt><r/><r/>
　Performs a bitwise exclusive OR of %propobj and %src and stores the result in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>band</kw>, <kw>bandpd</kw>, <kw>bandpi</kw>, <kw>bandp</kw><r/>(bitwise and)</dt>
<dd>
Format: <tt>band %dest, %src</tt><r/><r/>
　Performs a bitwise AND of %dest and %src and stores the result in %dest.<r/><r/>
Format: <tt>bandpd %res, %obj.*name, %src</tt><r/><r/>
　Performs a bitwise AND of %obj.*name and %src and stores the result in %obj.*name.<r/><r/>
Format: <tt>bandpi %res, %obj.%name, %src</tt><r/><r/>
　Performs a bitwise AND of %obj.%name and %src and stores the result in %obj.%name.<r/><r/>
Format: <tt>bandp %res, %propobj, %src</tt><r/><r/>
　Performs a bitwise AND of %propobj and %src and stores the result in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>sar</kw>, <kw>sarpd</kw>, <kw>sarpi</kw>, <kw>sarp</kw><r/>(shift arithmetic right)</dt>
<dd>
Format: <tt>sar %dest, %src</tt><r/><r/>
　%dest is arithmetically shifted right by the number of times represented by %src, and the result is stored in %dest.<r/><r/>
Format: <tt>sarpd %res, %obj.*name, %src</tt><r/><r/>
　The result of arithmetic right shift of %obj.*name by the number of times represented by %src is stored in %obj.*name.<r/><r/>
Format: <tt>sarpi %res, %obj.%name, %src</tt><r/><r/>
　The result of arithmetic right shift of %obj.%name by the number of times represented by %src is stored in %obj.%name.<r/><r/>
Format: <tt>sarp %res, %propobj, %src</tt><r/><r/>
　%propobj is arithmetically shifted right by the number of times represented by %src, and the result is stored in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>sal</kw>, <kw>salpd</kw>, <kw>salpi</kw>, <kw>salp</kw><r/>(shift arithmetic left)</dt>
<dd>
Format: <tt>sal %dest, %src</tt><r/><r/>
　%dest is arithmetically shifted left by the number of times represented by %src, and the result is stored in %dest.<r/><r/>
Format: <tt>salpd %res, %obj.*name, %src</tt><r/><r/>
　The result of arithmetic left shift of %obj.*name by the number of times represented by %src is stored in %obj.*name.<r/><r/>
Format: <tt>salpi %res, %obj.%name, %src</tt><r/><r/>
　Store the result of arithmetic left shift of %obj.%name by the number of times represented by %src in %obj.%name.<r/><r/>
Format: <tt>salp %res, %propobj, %src</tt><r/><r/>
　%propobj is shifted left by the number of times represented by %src, and the result is stored in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>sr</kw>, <kw>srpd</kw>, <kw>srpi</kw>, <kw>srp</kw><r/>(shift bitwise right)</dt>
<dd>
Format: <tt>sr %dest, %src</tt><r/><r/>
　%dest is shifted to the right by the number of times represented by %src, and the result is stored in %dest.<r/><r/>
Format: <tt>srpd %res, %obj.*name, %src</tt><r/><r/>
　%obj.*name is shifted to the right by the number of times represented by %src, and the result is stored in %obj.*name.<r/><r/>
Format: <tt>srpi %res, %obj.%name, %src</tt><r/><r/>
　%obj.%name is shifted right by the number of times represented by %src, and the result is stored in %obj.%name.<r/><r/>
Format: <tt>srp %res, %propobj, %src</tt><r/><r/>
　%propobj is shifted right by the number of times represented by %src, and the result is stored in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>add</kw>, <kw>addpd</kw>, <kw>addpi</kw>, <kw>addp</kw><r/>(add)</dt>
<dd>
Format <tt>add %dest, %src</tt><r/><r/>
　Add %src to %dest and store the result in %dest.<r/><r/>
Format <tt>addpd %res, %obj.*name, %src</tt><r/><r/>
　Add %src to %obj.*name and store the result in %obj.*name.<r/><r/>
Format <tt>addpi %res, %obj.%name, %src</tt><r/><r/>
　Add %src to %obj.%name and store the result in %obj.%name.<r/><r/>
Format <tt>addp %res, %propobj, %src</tt><r/><r/>
　Add %src to %propobj and store the result in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>sub</kw>, <kw>subpd</kw>, <kw>subpi</kw>, <kw>subp</kw><r/>(subtract)</dt>
<dd>
Format: <tt>sub %dest, %src</tt><r/><r/>
　Subtract %src from %dest and stores the result in %dest.<r/><r/>
Format: <tt>subpd %res, %obj.*name, %src</tt><r/><r/>
　Subtract %src from %obj.*name and store the result in %obj.*name.<r/><r/>
Format: <tt>subpi %res, %obj.%name, %src</tt><r/><r/>
　Subtract %src from %obj.%name and store the result in %obj.%name.<r/><r/>
Format: <tt>subp %res, %propobj, %src</tt><r/><r/>
　Subtracts %src from %propobj and stores the result in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>mod</kw>, <kw>modpd</kw>, <kw>modpi</kw>, <kw>modp</kw><r/>(modulo)</dt>
<dd>
Format: <tt>mod %dest, %src</tt><r/><r/>
　Store the remainder of %dest divided by %src in %dest.<r/><r/>
Format: <tt>modpd %res, %obj.*name, %src</tt><r/><r/>
　Store the remainder of %obj.*name divided by %src in %obj.*name.<r/><r/>
Format: <tt>modpi %res, %obj.%name, %src</tt><r/><r/>
　Store the remainder of %obj.%name divided by %src in %obj.%name.<r/><r/>
Format: <tt>modp %res, %propobj, %src</tt><r/><r/>
　Store the remainder of %propobj divided by %src in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>div</kw>, <kw>divpd</kw>, <kw>divpi</kw>, <kw>divp</kw><r/>(real divide)</dt>
<dd>
Format: <tt>div %dest, %src</tt><r/><r/>
　Divide %dest by real number by %src and stores the result in %dest.<r/><r/>
Format: <tt>divpd %res, %obj.*name, %src</tt><r/><r/>
　Divide %obj.*name by real number by %src and store the result in %obj.*name.<r/><r/>
Format: <tt>divpi %res, %obj.%name, %src</tt><r/><r/>
　Divide %obj.* name by real number by %src and store the result in %obj.*name.<r/><r/>
Format: <tt>divp %res, %propobj, %src</tt><r/><r/>
　Divide %propobj by real number by %src and stores the result in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>idiv</kw>, <kw>idivpd</kw>, <kw>idivpi</kw>, <kw>idivp</kw><r/>(integer divide)</dt>
<dd>
Format: <tt>idiv %dest, %src</tt><r/><r/>
　Divide %dest by %src by integer and store the result in %dest.<r/><r/>
Format: <tt>idivpd %res, %obj.*name, %src</tt><r/><r/>
　Divide %obj.*name by %src by integer and store the result in %obj.*name.<r/><r/>
Format: <tt>idivpi %res, %obj.%name, %src</tt><r/><r/>
　Divide %obj.%name by %src by integer and store the result in %obj.%name.<r/><r/>
Format: <tt>divp %res, %propobj, %src</tt><r/><r/>
　Divide %propobj by %src and store the result in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>mul</kw>, <kw>mulpd</kw>, <kw>mulpi</kw>, <kw>mulp</kw><r/>(multiply)</dt>
<dd>
Format: <tt>mul %dest, %src</tt><r/><r/>
　Multiplies %dest by %src and stores the result in %dest.<r/><r/>
Format: <tt>mulpd %res, %obj.*name, %src</tt><r/><r/>
　Multiplies %obj.*name by %src and stores the result in %obj.*name.<r/><r/>
Format: <tt>mulpi %res, %obj.%name, %src</tt><r/><r/>
　Multiplies %obj.%name by %src and stores the result in %obj.%name.<r/><r/>
Format: <tt>mulp %res, %propobj, %src</tt><r/><r/>
　Multiplies %propobj by %src and stores the result in %propobj.<r/><r/>
　Among the above instructions, those with %res as a parameter will also store the result in %res if res is not 0.<r/>
</dd>


<dt><kw>bnot</kw><r/>(bitwise not)</dt>
<dd>
Format: <tt>bnot %reg</tt><r/><r/>
　Invert %reg bitwise and store it again in %reg.
</dd>


<dt><kw>asc</kw><r/>(make ascii string)</dt>
<dd>
Format: <tt>asc %reg</tt><r/><r/>
　Creates one character corresponding to the number represented by %reg and stores it again in %reg.
</dd>


<dt><kw>chr</kw><r/>(cheracter code)</dt>
<dd>
Format: <tt>chr %reg</tt><r/><r/>
　Store the character code of the first character of the character string represented by %reg in %reg.
</dd>


<dt><kw>num</kw><r/>(number)</dt>
<dd>
Format: <tt>num %reg</tt><r/><r/>
　Converts the register represented by %reg to a number.
</dd>


<dt><kw>chs</kw><r/>(change sign)</dt>
<dd>
Format: <tt>chs %reg</tt><r/><r/>
　Reverses the sign of the number in the register represented by %reg.
</dd>


<dt><kw>inv</kw><r/>(invalidate)</dt>
<dd>
Format: <tt>inv %reg</tt><r/><r/>
　Invalidates the object represented by %reg.
</dd>


<dt><kw>chkinv</kw><r/>(invalidate)</dt>
<dd>
Format: <tt>chkinv %reg</tt><r/><r/>
　Set %reg to true if the object represented by% reg has not been invalidated; otherwise, set it to false.
</dd>


<dt><kw>int</kw><r/>(convert to integer)</dt>
<dd>
Format: <tt>int %reg</tt><r/><r/>
　Converts the register represented by %reg to an integer.
</dd>


<dt><kw>real</kw><r/>(convert to real)</dt>
<dd>
Format: <tt>real %reg</tt><r/><r/>
　Converts the register represented by %reg to a real number.
</dd>


<dt><kw>string</kw><r/>(convert to string)</dt>
<dd>
Format: <tt>string %reg</tt><r/><r/>
　Converts the register represented by %reg to a string.
</dd>


<dt><kw>octet</kw><r/>(convert to octet)</dt>
<dd>
Format: <tt>octet %reg</tt><r/><r/>
　Converts the register represented by %reg to an octet sequence.
</dd>


<dt><kw>typeof</kw>, <kw>typeofd</kw>, <kw>typeofi</kw><r/>(check type)</dt>
<dd>
Format: <tt>typeof %reg</tt><r/>
Format: <tt>typeofd %obj.*name</tt><r/>
Format: <tt>typeofi %obj.%name</tt><r/>
<r/>
　Examine the type of %reg or %obj.*name or %obj.%name and store the string representing that type in %reg or %obj.*name or %obj.%name again.
</dd>


<dt><kw>eval</kw><r/>(evaluate expression)</dt>
<dd>
Format: <tt>eval %reg</tt><r/><r/>
　Executes the string represented by %reg as an expression and stores the result in %reg again.
</dd>


<dt><kw>eexp</kw><r/>(execute expression)</dt>
<dd>
Format: <tt>eexp %reg</tt><r/><r/>
　Executes the string represented by %reg as an expression and discards the result.
</dd>


<dt><kw>chkins</kw><r/>(check instance)</dt>
<dd>
Format: <tt>chkins %reg, %classname</tt><r/><r/>
　If the object represented by %reg is an instance of the class with the class name represented by %classname, store true in %reg, otherwise store false.
</dd>


<dt><kw>call</kw>, <kw>calld</kw>, <kw>calli</kw><r/>(function call)</dt>
<dd>
Format: <tt>call %dest, %func(%arg1, %arg2, %arg3, ...)</tt><r/>
Format: <tt>calld %dest, %obj.*name(%arg1, %arg2, %arg3, ...)</tt><r/>
Format: <tt>calli %dest, %obj.%name(%arg1, %arg2, %arg3, ...)</tt><r/>
<r/>
　Calls the function object represented by %func or %obj.*name or %obj.%name with the arguments %arg1,%arg2,%arg3 ... and stores the result in %dest. If %dest is %0, the result is discarded (not stored in %0).
</dd>


<dt><kw>new</kw><r/>(create new)</dt>
<dd>
Format: <tt>new %dest, %func(%arg1, %arg2, %arg3, ...)</tt><r/><r/>
　Constructs a class object represented by %func with the arguments %arg1, %arg2, %arg3 ... and stores the result in %dest.
</dd>


<dt><kw>gpd</kw>, <kw>gpds</kw><r/>(get property direct)</dt>
<dd>
Format: <tt>gpd %dest, %obj.*name</tt><r/>
Format: <tt>gpds %dest, %obj.*name</tt><r/>
<r/>
　Reference the member represented by *name from the object represented by %obj and copy its value to %dest.<r/>
　gpd involves calling a property handler, but gpds does not call the property handler and gets the property object itself.
</dd>


<dt><kw>gpi</kw>, <kw>gpis</kw><r/>(get property indirect)</dt>
<dd>
Format: <tt>gpi %dest, %obj.%name</tt><r/>
Format: <tt>gpis %dest, %obj.%name</tt><r/>
<r/>
　References the member represented by %name from the object represented by %obj and copies its value to %dest.<r/>
　gpi involves calling a property handler, but gpis does not call a property handler and gets the property object itself.
</dd>


<dt><kw>spd</kw>, <kw>spde</kw>, <kw>spdeh</kw>, <kw>spds</kw><r/>(set property direct)</dt>
<dd>
Format: <tt>spd %obj.*name</tt><r/>
Format: <tt>spde %obj.*name</tt><r/>
Format: <tt>spdeh %obj.*name</tt><r/>
Format: <tt>spds %obj.*name</tt><r/>
<r/>
　Assign the value of %src to the member represented by *name of the object represented by %obj.<r/>
　spd performs normal access, but raises an exception if the member does not exist.<r/>
　spde creates a new member if it does not exist.<r/>
　spdeh sets the member as a hidden member. It has no meaning in the current version.<r/>
　spds does not call the property handler and replaces the property object itself.
</dd>


<dt><kw>spi</kw>, <kw>spie</kw>, <kw>spis</kw><r/>(set property indirect)</dt>
<dd>
Format: <tt>spi %obj.%name</tt><r/>
Format: <tt>spie %obj.%name</tt><r/>
Format: <tt>spis %obj.%name</tt><r/>
<r/>
　Assign the value of %src to the member represented by %name of the object represented by %obj.<r/>
　spi performs normal access, but raises an exception if the member does not exist.<r/>
　spie creates a new member if it does not exist.<r/>
　spis does not call the property handler and replaces the property object itself.
</dd>


<dt><kw>getp</kw></dt>
<dd>
Format: <tt>getp %reg, %propobj</tt><r/>
<r/>
　Operate the property object getter represented by %propobj to get the property value and assign it to %reg. Performs the operation of the unary '*' operator.<r/>
</dd>

<dt><kw>setp</kw></dt>
<dd>
Format: <tt>setp %propobj, %reg</tt><r/>
<r/>
　Operate the setter of the property object represented by %propobj and set the value of %reg. Performs the operation of the unary '*' operator.<r/>
</dd>

<dt><kw>deld</kw>, <kw>deli</kw><r/>(delete member)</dt>
<dd>
Format: <tt>deld %reg, %obj.*name</tt><r/>
Format: <tt>deli %reg, %obj.%name</tt><r/>
<r/>
　Deletes the member represented by *name or %name of the object represented by %obj.<r/>
　Stores whether the deletion was successful or not in %reg, but discards the result if %reg is %0.
</dd>


<dt><kw>srv</kw><r/>(set result value)</dt>
<dd>
Format: <tt>srv %reg</tt><r/><r/>
　Returns the value of %reg as the return value of the function (the return value of the function is the value represented by %reg).
</dd>


<dt><kw>ret</kw><r/>(return)</dt>
<dd>
Format: <tt>ret</tt><r/><r/>
　Return to caller.
</dd>


<dt><kw>entry</kw><r/>(enter try block)</dt>
<dd>
Format: <tt>entry ip, %reg</tt><r/><r/>
　Enter an exception-protected block. If an exception occurs, jump to ip and set the exception object to %reg.
</dd>


<dt><kw>extry</kw><r/>(exit from try block)</dt>
<dd>
Format: <tt>extry</tt><r/><r/>
　Exit from an exception-protected block.
</dd>


<dt><kw>throw</kw><r/>(throw exception object)</dt>
<dd>
Format: <tt>throw %reg</tt><r/><r/>
　Throws the object represented by %reg as an exception object.
</dd>


<dt><kw>chgthis</kw><r/>(change this)</dt>
<dd>
Format: <tt>chgthis %dest, %src</tt><r/><r/>
　Changes the closure part of the object represented by% dest to the object represented by %src.
</dd>


<dt><kw>global</kw><r/>(get global object)</dt>
<dd>
Format: <tt>global %dest</tt><r/><r/>
　Store the global object in %dest.
</dd>


<dt><kw>addci</kw><r/>(add class instance information)</dt>
<dd>
Format: <tt>addci %dest, %info</tt><r/><r/>
　Add %info to the class instance information of the object represented by %dest.
</dd>

<dt><kw>regmember</kw><r/>(register members)</dt>
<dd>
Format: <tt>regmember</tt><r/><r/>
　Register a member of the class with the "this" object. Used internally.
</dd>



<dt><kw>debugger</kw><r/>(call debugger)</dt>
<dd>
Format: <tt>debugger</tt><r/><r/>
　Suspend execution and invoke the debugger. The current version of the implementation calls the native debugger instead of the TJS2 debugger.
</dd>


</dl>

</para>

</doc>

