<?xml version="1.0" encoding="UTF-8" ?>
<doc>
<title>Expressions and operators</title>

<para>
<ptitle>Expressions and operators</ptitle>
　A <kw>expression</kw> is a collection of operators and operands, or an immediate.<r/>
<r/>
　Usually, you can write the following in the script.<r/>
<r/>
<tt>
	expression;<r/>
</tt>
<r/>
　Putting a semicolon after the expression in this way causes the expression to be evaluated (= executed) in place and the result of the expression to be discarded.<r/>
<r/>
<example>
	a = b;<r/>
	// Variable b is assigned to variable a by operation of operator =<r/>
<r/>
	func();<r/>
	// The operation of the operator ( ) calls func as a function, but returns the function<r/>
	// Is thrown away<r/>
<r/>
	1 + 3;<r/>
	// The operation of the + operator adds 1 and 3, but discards the result (in fact, this expression has no meaning and is not even executed)
</example>
</para>

<para>
<ptitle>True and false</ptitle>
　Some operators handle true or false (boolean). False if the result of the operation is 0; true if the result is nonzero.<r/>
　If the string is asked for truth, it is false if it is an empty string; otherwise, if the attempt to convert it to a number succeeds, the result as the number becomes true or false, and if it fails, false It becomes.<r/>
</para>

<para>
<ptitle>operator</ptitle>
　In the following, the operators are described in order of decreasing precedence.<r/>
</para>


<para>
<ptitle>if operator</ptitle>
　The if operator <tt>if</tt> evaluates what is on the left only if the result on the right is true.<r/>
<example>
	a=b if b!=0; // If b is not 0, assign b to a<r/>
</example>
<r/>
　You cannot get the result of the operator.<r/>
</para>

<para>
<ptitle>Sequential operator</ptitle>
　The sequential operator <tt><kw>,</kw></tt> (comma) evaluates what is on the left and then what is on the right. I will not do anything else. The whole operator is the result of evaluating what is on the right. If multiple commas are written consecutively, they are evaluated in order from the one on the left.<r/>
<example>
	c = (a=1, b=2); // a = 1, b = 2 is evaluated, and c is assigned 2<r/>
	a=1, b=2, c=3; // a = 1, b = 2, c = 3 are evaluated in this order<r/>
</example>
</para>

<para>
<ptitle>Assignment operator</ptitle>
　The assignment operators are as follows:<r/>
<r/>
<tt><kw>=</kw>  <kw>&lt;-></kw>  <kw>&amp;=</kw>  <kw>|=</kw>  <kw>^=</kw>  <kw>-=</kw>  <kw>+=</kw>  <kw>%=</kw>  <kw>/=</kw>  <kw>\=</kw>  <kw>*=</kw>  <kw>||=</kw>  <kw>&amp;&amp;=</kw>  <kw>>>=</kw>  <kw>&lt;&lt;=</kw>  <kw>>>>=</kw></tt>
<r/>
　Of these, the = operator is a simple assignment operator that assigns the result of the evaluation on the right to the one on the left, and the value of the entire operator is the result of the evaluation on the right.<r/>
<example>
	a = 0;  // assign 0 to a<r/>
	a = b = c = 0; // Substitute 0 in the order of c, b, a<r/>
</example>
<r/>
　The <tt>&lt;-></tt> operator performs the change. Evaluate the left one first, then the right one. Then, assign the result of evaluating the right side to the left side, and assign the result of evaluating the left side to the right side. You cannot get the result of the operator.<r/>
　At this time, each of the left and right expressions is <b>evaluated twice</b> to get the value of the expression and to assign it to the expression. This specification may be changed in the future, so please do not rely on the number of evaluations.<r/>
<r/>
　All other operators have the form <tt>operator =</tt>, and if <tt>A operator = B</tt> is written, then <tt>A = A operator means B</tt>. The value of the entire operator is the result of the operation.<r/>
</para>

<para>
<ptitle>Conditional operator</ptitle>
　The conditional operator <tt><kw>?:</kw></tt> is a ternary operator. Writing in the form <tt>A? B: C</tt> evaluates A, evaluates B if true, and ignores C. If false, evaluate C and ignore B. The value of the entire operator is the evaluated value of B or C.<r/>
<r/>
　Conditional operators can be used as lvalues.<r/>
<example>
	a = b==0 ? c : b; // If b is 0, substitute c for a; if b is not 0, substitute b for a<r/>
	b==0 ? (a=c) : (a=b); // Same meaning as above<r/>
	(a ? b : c ) = d; // Assign b to b if a is true, and d to c if a is false (example of using as an lvalue)<r/>
</example>
</para>

<para>
<ptitle>Logical OR operator</ptitle>
　The logical OR operator <tt><kw>||</kw></tt> evaluates what is on the left first, ignores what is on the right if true, and returns Be true. If the result on the left is false, the result on the right is evaluated and the result is the result of the entire operator.<r/>
</para>

<para>
<ptitle>Logical AND operator</ptitle>
　The logical AND operator <tt><kw>&amp;&amp;</kw></tt> evaluates what is on the left first, ignores what is on the right if false, and returns false as a result of the entire operator. It becomes. If the result on the left is true, the result on the right is the result of the entire operator.<r/>
</para>

<para>
<ptitle>Bitwise OR operator</ptitle>
　The bitwise OR operator <tt><kw>|</kw></tt> performs a bitwise logical OR. The values on the left and then on the right are evaluated in that order, and the result is an integer, and the bitwise OR is taken as the value of the entire operator.<r/>
</para>

<para>
<ptitle>Bit XOR operator</ptitle>
　The bit XOR operator <tt><kw>^</kw></tt> performs a bitwise logical XOR. The values on the left and then on the right are evaluated in that order, and the result is taken as an integer and XORed bitwise to get the value of the entire operator.<r/>
</para>

<para>
<ptitle>Bit AND operator</ptitle>
　The bitwise AND operator <tt><kw>&amp;</kw></tt> performs a bitwise logical AND. The values on the left and then on the right are evaluated in order, and the result is an integer, and the result of the bitwise AND is the value of the entire operator.<r/>
</para>

<para>
<ptitle>Identification operator</ptitle>
　<tt><kw>==</kw>  <kw>!=</kw>  <kw>===</kw>  <kw>!==</kw></tt> are kinds of identification operator.<r/>
<r/>
<dl>

<dt><tt>==</tt> operator</dt>
<dd>The <tt>==</tt> operator evaluates what is on the left first, and then what is on the right. If they match, the whole operator is true; if they do not match, the whole operator is false. If the result of the operation on both sides is different, they are converted appropriately before comparison. For example, <tt>-1 == '-1'</tt> is true.</dd>

<dt><tt>!=</tt> operator</dt>
<dd>The <tt>!=</tt> operator is the opposite of the <tt>==</tt> operator.</dd>

<dt><tt>===</tt> operator</dt>
<dd>The <tt>===</tt> operator is called an identity comparison operator, and is the same as the <tt>==</tt> operator, except that no type conversion is performed and even the types match. Otherwise it will not be true.</dd>

<dt><tt>!==</tt> operator</dt>
<dd>The <tt>!==</tt> operator is the opposite of the <tt>===</tt> operator.</dd>
</dl>
</para>

<para>
<ptitle>Comparison operator</ptitle>
　<tt><kw>&lt;</kw>  <kw>></kw>  <kw>&lt;=</kw>  <kw>>=</kw></tt> are kinds of comparison operator.<r/>
<r/>
<dl>

<dt><tt>&lt;</tt> operator</dt>
<dd>The <tt>&lt;</tt> operator evaluates what is on the left first and what is on the right next. True if the result of evaluating the left is less than the result of evaluating the right, false otherwise.</dd>

<dt><tt>></tt> operator</dt>
<dd>The <tt>></tt> operator evaluates what is on the left first and what is on the right next. True if the result of evaluating the right is less than the result of evaluating the left, false otherwise.</dd>

<dt><tt>&lt;=</tt> operator</dt>
<dd>The <tt>&lt;=</tt> operator evaluates what is on the left first and what is on the right next. True if the result of evaluating the left is less than or equal to the result of evaluating the right, false otherwise.</dd>

<dt><tt>>=</tt> operator</dt>
<dd>The <tt>>=</tt> operator evaluates what is on the left first and what is on the right next. True if the result of evaluating the right side is less than or equal to the result of evaluating the left side, false otherwise.</dd>
</dl>
<r/>
　If both comparisons are strings, the comparison is in wide character code order (usually UNICODE).<r/>
</para>

<para>
<ptitle>Bit shift operator</ptitle>
　<tt><kw>>></kw>  <kw>&lt;&lt;</kw>  <kw>>>></kw></tt> are kinds of bit shift operator.<r/>
<r/>
<dl>

<dt><tt>>></tt> operator</dt>
<dd>The <tt>>></tt> operator evaluates what is on the left first, and then what is on the right. The result on the left side is an integer, and the result of the operation on the right is signed bit-shifted to the right by the number of times on the right side.</dd>

<dt><tt>&lt;&lt;</tt> operator</dt>
<dd>The <tt>&lt;&lt;</tt> operator evaluates what is on the left first, and then what is on the right. Using the result on the left as an integer and shifting the bit to the left by the number of times the result on the right results in the entire operator.</dd>

<dt><tt>>>></tt> operator</dt>
<dd>The <tt>>>></tt> operator is the same as the <tt>>></tt> operator, but treats the result of evaluating the left side as an unsigned integer.</dd>
</dl>
</para>

<para>
<ptitle>Addition and subtraction operators</ptitle>
　<tt><kw>+</kw>  <kw>-</kw></tt> are the addition and subtraction operators, respectively.<r/>
<r/>
<dl>

<dt><tt>+</tt> operator</dt>
<dd>The <tt>+</tt> operator evaluates the left side first, then the right side. If both results are numeric, the addition is done numerically, resulting in the entire operator. If either or both are strings, the additions are performed as strings, and the overall operator is a string consisting of the left result followed by the right result. Numeric values are converted to strings, and object types are converted to strings if possible.</dd>

<dt><tt>-</tt> operator</dt>
<dd>The <tt>-</tt> operator evaluates the left side first, then the right side. Then, the result on the left is subtracted from the result on the left as a number, which is the value of the entire operator.</dd>
</dl>
</para>

<para>
<ptitle>Multiplicative division operator</ptitle>
　<tt><kw>%</kw>  <kw>/</kw>  <kw>\</kw>  <kw>*</kw></tt> are the remainder, division, integer division, and multiplication operators, respectively.<r/>
<r/>
<dl>

<dt><tt>%</tt> operator</dt>
<dd>The <tt>%</tt> operator evaluates the left side first, then the right side. Then the remainder of the left divided by the right is the value of the entire operator. Both values are treated as integers.</dd>

<dt><tt>/</tt> operator</dt>
<dd>The <tt>/</tt> operator evaluates the left side first, then the right side. Then the value of the left divided by the right is the value of the entire operator. Values are treated as real numbers.</dd>

<dt><tt>\</tt> operator</dt>
<dd>The <tt>\</tt> operator performs division like the / operator, but treats the value as an integer.</dd>

<dt><tt>*</tt> operator</dt>
<dd>The <tt>*</tt> operator evaluates the left side first, then the right side. After that, the value multiplied by the left side by the right side becomes the value of the whole operator. Values are treated as real numbers.</dd>
</dl>
</para>

<para>
<ptitle>A class of common unary operators</ptitle>
　The following are all unary operators (except <tt>instanceof</tt>).<r/>
<r/>
<dl>

<dt><tt><kw>!</kw></tt> operator</dt>
<dd>The prefix <tt>!</tt> operator is the logical NOT operator. The value of the whole operator is the result of evaluating the right-hand side and reversing the truth.</dd>

<dt><tt><kw>~</kw></tt> operator</dt>
<dd>The <tt>~</tt> operator is a bitwise negation operator. The value on the right side is evaluated as an integer, and the result of bitwise negation (1 → 0, 0 → 1) is the value of the entire operator.</dd>

<dt><tt><kw>--</kw></tt> operator</dt>
<dd>The prefix <tt>--</tt> operator is the prefix <kw>decrement</kw> operator. One is subtracted from the one on the right, and the value after subtraction is the value of the entire operator.</dd>

<dt><tt><kw>++</kw></tt> operator</dt>
<dd>The prefix <tt>++</tt> operator is the prefix <kw>increment</kw> operator. One is added to the one on the right, and the value after the addition is the value of the entire operator.</dd>

<dt><tt><kw>new</kw></tt> operator</dt>
<dd>The <tt>new</tt> operator causes the function evaluation expression on the right to create an object instead of a function call.</dd>

<dt><tt><kw>invalidate</kw> operator</tt></dt>
<dd>The <tt>invalidate</tt> operator evaluates what is on the right and invalidates the resulting object. If the object on the right is a void, string, number, or octet sequence, do nothing. Does nothing if the object has already been invalidated. An exception will be raised if null is specified.</dd>

<dt><tt><kw>isvalid</kw> operator</tt></dt>
<dd>The <tt>isvalid</tt> operator evaluates what is on the right or left, and returns true if the resulting object is valid and false if it is invalid. Putting the operator before or after the evaluation target has the same meaning. Always returns true if the target is a void, string, number, or octet sequence. An exception will be raised if null is specified.</dd>

<dt><tt><kw>delete</kw> operator</tt></dt>
<dd>The <tt>delete</tt> operator deletes members or local variables of the object written on the right. True if the erase succeeds, false if the erase fails.</dd>

<dt><tt><kw>typeof</kw> operator</tt></dt>
<dd>The <tt>typeof</tt> operator evaluates what's on the right and returns the following string depending on its type: void: "void", integer: "Integer", real: "Real", object: "Object", String: "String", Octet column: "Octet". However, if the member of the object is specified and there is no member, it will be "undefined".</dd>

<dt><tt><kw>#</kw> operator</tt></dt>
<dd>The <tt>#</tt> operator evaluates what is on the right and takes the character code of the first character as a character string as the value of the entire operator.</dd>

<dt><tt><kw>$</kw> operator</tt></dt>
<dd>The <tt>$</tt> operator evaluates what is on the right, uses the result as the character code, and the character it represents as the value of the entire operator.</dd>

<dt><tt><kw>+</kw> operator</tt></dt>
<dd>The unary <tt><kw>+</kw></tt> operator evaluates what is on the right. Does nothing if the one on the right is a real number or an integer. Otherwise, it attempts to convert to a real or numeric value, and the result is the result of the entire operator. If you try to convert a string to a number, it will be 0 if the conversion fails and no exception is raised. It is converted to a real number if it contains a decimal point, otherwise it is converted to an integer. If the string starts with 0x, 0b, or 0, it is interpreted as hexadecimal, binary, or octal, respectively.</dd>

<dt><tt><kw>-</kw> operator</tt></dt>
<dd>The unary <tt>-</tt> operator evaluates what is on the left, evaluates the result as a number, and reverses the sign as the result of the entire operator.</dd>

<dt><tt><kw>&amp;</kw> operator</tt></dt>
<dd>The unary <tt>&amp;</tt> operator changes access to the members of the object written on the right to access the property object itself without going through the property handler. For example, if propobj = &amp;obj.prop ;, the property handler for the member property prop of obj is not invoked, and the reference to the <kw>property object</kw> itself of the member property prop is assigned to propobj. The behavior is undefined if the right is not a property access.</dd>

<dt><tt><kw>*</kw> operator</tt></dt>
<dd>The unary <tt>*</tt> operator activates the property handler for the object written on the right. On the right, you must write an expression that represents the property object. For example, * propobj = 1; calls the setter handler for the property object, propobj, and assigns 1.</dd>

<dt><tt><kw>instanceof</kw> operator</tt></dt>
<dd>The <tt>instanceof</tt> operator evaluates what is on the left and then what is on the right. On the right side, write what will be a string, which will be the class name, and on the left side, true if it is an instance of that class, false otherwise.</dd>
</dl>
</para>

<para>
<ptitle>Function calls, parentheses, post increment / decrement, etc.</ptitle>
<dl>

<dt><tt><kw>(  )</kw> operator</tt></dt>
<dd>The <tt>( )</tt> operator changes the precedence of an operation or makes a function call.</dd>

<dt><tt><kw>[  ]</kw> operator</tt></dt>
<dd>The <tt>[ ]</tt> operator is an indirect member selection operator. If <tt>A [B]</tt>, A is evaluated first, then B is evaluated. With B as a string, the member name is searched from A, and the entire operator is access to that member. When used as an lvalue, it also has the effect of creating a member B in the object, if not present.</dd>

<dt><tt><kw>.</kw> operator</tt></dt>
<dd>The <tt>.</tt> operator is a direct member selection operator. If <tt>A.B</tt> is written, evaluate A. Find B in A and access the member as a whole operator. When used as an lvalue, it also has the effect of creating a member B in the object, if not present.<r/>If the left side of the <tt>.</tt> operator is omitted, refer to members in the global object outside the with statement, and to members of the object indicated by with inside the with statement. To do.</dd>

<dt><tt><kw>++</kw> operator</tt></dt>
<dd>The postfix <tt>++</tt> operator is a postfix increment operator. One is added to the one on the left, and the whole operator is the one on the left before adding.</dd>

<dt><tt><kw>--</kw> operator</tt></dt>
<dd>The postfix <tt>--</tt> operator is a postfix decrement operator. One is subtracted from the one on the left, and the whole operator is the one on the left before it is subtracted.</dd>

<dt><tt><kw>!</kw> operator</tt></dt>
<dd>The trailing <tt>!</tt> operator is an expression evaluation operator. Interprets the result of evaluating what is on the left as a string, and interprets it as an expression string. The result is the result of interpreting and evaluating the expression string. Expressions work in the this context (this in the position where this operator is used).</dd>

<dt><tt><kw>incontextof</kw> operator</tt></dt>
<dd>The <tt>incontextof</tt> operator evaluates what is on the left first, and then what is on the right. The result of evaluating the object on the left is an object, and the context part of the object is replaced with the result of evaluating the object on the right to be the result of the entire operation.</dd>

<dt><tt><kw>int</kw> operator</tt></dt>
<dd>The int operator evaluates what is on the right and converts it to an integer type, resulting in the entire operator. You can also write (int) like a C-style cast.</dd>

<dt><tt><kw>real</kw> operator</tt></dt>
<dd>The real operator evaluates what is on the right and converts it to a real type, resulting in the entire operator. You can also write (real) like a C-language cast.</dd>

<dt><tt><kw>string</kw> operator</tt></dt>
<dd>The string operator evaluates what is on the right, converts it to a string type, and the result is the entire operator. You can also write (string) in the style of a C-style cast.</dd>
</dl>
</para>

</doc>
