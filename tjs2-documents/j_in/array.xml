<?xml version="1.0" encoding="UTF-8" ?>
<doc>

<title>Array クラス</title>

<para>
<ptitle>Array クラス</ptitle>
　Array クラスは<kw>配列</kw>を扱うクラスです。<r/>
<r/>
　このクラスのオブジェクトを作成し、間接メンバ選択演算子によって指定された添え字を使って配列のように扱うことができます。添え字は整数です。0は先頭の要素を表し、1はその次の要素を表します。負の整数を指定すると、配列の最後から指定したものとして扱われます (-1 は最後の要素を表します)。<r/>
<example>
	var a = new Array();<r/>
	var i;<r/>
	for(i=0;i&lt;100;i++) a[i]=i;<r/>
</example>
<r/>
　配列の大きさは宣言する必要はありません。指定された添え字の大きさまで自動的にサイズが拡張され、何も値が代入されていない要素は void に初期化されます。<r/>
<r/>
　また、count プロパティがあり、これが配列のサイズを表しています。count プロパティに値を代入しても配列のサイズを変えることができます。<r/>
</para>


<para>
<ptitle>式中配列</ptitle>
　<tt><kw>[ ]</kw></tt> を使って、式中に <tt>Array</tt> クラスのオブジェクトをその場で記述することができます。<tt>[ ]</tt> にはカンマで区切り、初期要素となる式を列挙します。たとえば、<r/>
<tt>
	var ar = ["a", "b", "c"];
</tt>
　と記述すれば、<tt>ar</tt> に、 <tt>"a" "b" "c"</tt> の要素が入った <tt>Array</tt> クラスのオブジェクトへの参照が代入されます。<r/>
</para>

<para>
<ptitle>count</ptitle>
　count プロパティは、配列の大きさを表します。<r/>
</para>

<para>
<ptitle>load</ptitle>
　load メソッドは、配列をファイルから読み込みます。<r/>
<bq>
構文 : load(&lt;ファイル名>, &lt;モード=''>)<r/>
</bq>
　テキストファイルから配列を読み込みます。ファイルのテキストが一行づつ、各要素に入り、最終的に count プロパティはファイルの行数と同じになります。<r/>
　モードには、ファイルを読み込む際のモード文字列を指定します。これは TJS が動作している環境によって異なります。"o" に続いてオフセットを10進で指定するとファイルのそのバイト位置からの読み込みになります。<r/>
　TJS が動作している環境によってはこのメソッドと save メソッド、 saveStruct メソッドは使用できません。<r/>
　load メソッドは、この Array クラスのオブジェクト自身を返します。<r/>
</para>

<para>
<ptitle>save</ptitle>
　save メソッドは、配列をファイルに書き出します。<r/>
<bq>
構文 : save(&lt;ファイル名>, &lt;モード=''>)<r/>
</bq>
　配列をファイルに書き出します。一行ずつ、各メンバが出力されますが、オブジェクトやクラス、関数などへの参照は空行となります。<r/>
　モードには、ファイルを書き込む際のモード文字列を指定します。これは TJS が動作している環境によって異なりますが、吉里吉里の場合は "c" を指定するとファイルに簡単な暗号化がかかります ( そのまま load メソッドで読み込むことができます ) 。"z" を指定するとファイルを圧縮して保存できます ("c" と併用は出来ません; これもそのまま load メソッドで読み込むことができます)。"o" に続いてオフセットを10進で指定するとファイルのそのバイト位置からの書き込みになります。"b"を指定するとバイナリ形式で保存されます(他のモード指定と併用は出来ません; これもそのまま load メソッドで読み込むことができます)。<r/>
　save メソッドは、この Array クラスのオブジェクト自身を返します。<r/>
</para>

<para>
<ptitle>split</ptitle>
　split メソッドは、文字列を分割します。<r/>
<bq>
構文 : split(&lt;パターン/デリミタ集合>, &lt;文字列>, &lt;(予約)>, &lt;空の要素を無視するか=false>)
</bq>
　配列を初期化し、この配列に、文字列をパターンまたはデリミタ集合で区切った物をコピーします。<r/>
　第１引数にはパターンまたはデリミタ集合を指定します。<r/>
　パターンは正規表現オブジェクトである必要があります。<r/>
　デリミタ集合には、区切り記号となる文字を指定します。文字列を指定することで区切り文字を複数指定できます。<r/>
　第３引数は将来のバージョンのために予約されています。<r/>
　空の要素を無視するか、では、空の要素 ( たとえばカンマをデリミタにしているときに ,,,,, など ) の場合にその要素を配列にコピーしない場合は true を指定します。<r/>
　引数の順番に注意してください。<r/>
</para>

<para>
<ptitle>join</ptitle>
　join メソッドは、配列を結合し、一つの文字列にします。<r/>
<bq>
構文 : join(&lt;デリミタ>, &lt;(予約)>, &lt;空の要素を無視するか=false>)
</bq>
　配列の各要素をデリミタで結合し、結合した文字列を返します。<r/>
　空の要素を無視するか、が true の場合は、要素中の void は無視されます。<r/>
<example>
	var ar = [ "a", "b", void, "d" ];<r/>
	var s1 = ar.join(","); // s1 には "a,b,,d" が代入される<r/>
	var s2 = ar.join(",",,true); // s2 には "a,b,d" が代入される<r/>
</example>
</para>

<para>
<ptitle>reverse</ptitle>
　reverse メソッドは、配列の要素の並びを逆さまにします。<r/>
<bq>
構文 : reverse()<r/>
</bq>
</para>

<para>
<ptitle>sort</ptitle>
　sort メソッドは、配列をソート(並び替え)します。<r/>
<bq>
構文 : sort(&lt;ソート順='+'>, &lt;安定ソートを行うか=false>)
</bq>
　ソート順は以下の文字列のどれかです。昇順では小さい物から大きい物へと並び替えられ、降順はその逆です。省略すると '+' を指定されたと見なされます。<r/>
<bq>
"+"  : 昇順 (通常の &lt; 演算子での比較)<r/>
"-"  : 降順<r/>
"0"  : 数値による昇順 ( 10,2,1 は 1,2,10 に並び替えられます )<r/>
"9"  : 数値による降順<r/>
"a"  : 文字列による昇順 ( "a","c","b" は "a","b","c" に並び替えられます )<r/>
"z"  : 文字列による降順<r/>
</bq>
　ソート順の文字の変わりに関数を指定することが出来ます。関数は２つの引数を持ちます。第１引数が第２引数よりも前に来るべき場合に真を返す関数を指定します (JavaScript の sort メソッドに渡す関数と、戻り値の意味が違うので注意してください )。<r/>
<r/>
　第２引数には、安定ソートを行うかどうかを指定します。省略すると false が指定されたと見なされ、不安定なソートが行われます。安定ソートは、同じ順位の配列要素の順番は、ソート後も同じ順番になります。不安定ソートの場合は同じ順位の配列要素の順番は、ソート後に同じ順番になる保証はありません。<r/>
<example>
	var array = [ 0, 1, 2, 10, 12, 14, 4, 6, 2 ];<r/>
	array.sort();<r/>
		// ↑ メソッド実行後、array は [0, 1, 2, 2, 4, 6, 10, 12, 14] に<r/>
	array.sort('-');<r/>
		// ↑ メソッド実行後、array は [14, 12, 10, 6, 4, 2, 2, 1, 0] に<r/>
	array.sort('a');<r/>
		// ↑ メソッド実行後、array は [0, 1, 10, 12, 14, 2, 2, 4, 6] に<r/>
<r/>
	var array = [ "hoge", "foo" , "bar", "baz" ];<r/>
	array.sort();<r/>
		// ↑ メソッド実行後、array は ["bar", "baz", "foo", "hoge"] に<r/>
<r/>
	var array = [ "abcd", "abc", "ab", "a" , "b", "c" ];<r/>
	array.sort(function(a,b) { return a&lt; b; } );<r/>
		// ↑ '+' の指定と同じ意味<r/>
<r/>
	var array = [ "abcd", "abc", "ab", "a" , "b", "c" ];<r/>
	array.sort(function(a,b) { return a.length &lt; b.length; } );<r/>
		// ↑ 文字列の長さの短い順<r/>
		// (長さが同じ"a" "b" "c" がソート後も "a" "b" "c"<r/>
		// の順番である保証はない)<r/>
<r/>
	var array = [ "abcd", "abc", "ab", "a" , "b", "c" ];<r/>
	array.sort(function(a,b) { return a.length &lt; b.length; }, true );<r/>
		// ↑ 文字列の長さの短い順<r/>
		// (長さが同じ"a" "b" "c" はソート後もこの順番である)<r/>
</example>
</para>

<para>
<ptitle>saveStruct</ptitle>
　saveStruct はファイルへ構造化されたデータの出力を行います。<r/>
<bq>
構文 : saveStruct(&lt;ファイル名>, &lt;モード=''>)<r/>
</bq>
　saveStruct メソッドは、要素の状態を復元可能な状態でファイルに出力します。<r/>
　各要素には文字列、実数、オクテット列、整数を含めることができます。また、要素にオブジェクトがあった場合は、それが Array クラスあるいは Dictionary クラスのオブジェクトである場合に限り、そのオブジェクトの中身もファイルに出力します。それ以外の要素は void が出力されます。<r/>
　たとえば、<r/>
<example>
	([ 1, 2, 3, [4, 5], %[ a : 1, b : 2 ], "文字列" ]).saveStruct("out.txt");<r/>
</example>
　では
<bq>
(const) [<r/>
	1,<r/>
	2,<r/>
	3,<r/>
	(const) [<r/>
		4,<r/>
		5<r/>
	],<r/>
	(const) %[<r/>
		"a" => 1,<r/>
		"b" => 2<r/>
	],<r/>
	"文字列"<r/>
]<r/>
</bq>
　のような内容が出力されます。これはこのファイル全体を一つの式として評価することにより、保存した時と同じ構造を復元できるものです。<r/>
　ここでの (const) は、 [ ] や %[ ] の中身が定数項しか無いことを表しています。コンパイラはこの(const) を見つけると、直後の式中辞書配列や式中配列を、中身が定数項しかないことと仮定して、高効率で読み込む事ができます。<r/>
　saveStruct メソッドは、この Array クラスのオブジェクト自身を返します。<r/>
</para>

<para>
<ptitle>assign</ptitle>
　assign メソッドは、配列をコピーします。<r/>
<bq>
構文 : assign(&lt;コピー元配列>)<r/>
</bq>
　引数で指定された他の配列の内容を、そっくりコピーします。<r/>
<r/>
　辞書配列 (Dictionaryクラスのオブジェクト) をコピー元配列に指定した場合は、その辞書配列の各メンバが、名前、値の順に交互に現れる配列となります。メンバの順番は不定となります。<r/>
</para>

<para>
<ptitle>assignStruct</ptitle>
　assignStruct メソッドは、配列を構造ごとコピーします。<r/>
<bq>
構文 : assignStruct(&lt;コピー元配列>)<r/>
</bq>
　引数で指定された他の配列の内容を、そっくりコピーします。<r/>
　assign メソッドと違い、メンバに配列あるいは辞書配列があった場合は、再帰的にその内容も
コピーします ( assign メソッドの場合は参照がコピーされるだけです )。<r/>
</para>

<para>
<ptitle>clear</ptitle>
　clear メソッドは、配列の要素をすべて削除します。<r/>
</para>

<para>
<ptitle>erase</ptitle>
　erase メソッドは、指定された添え字の要素を削除します。<r/>
<bq>
構文 : erase(&lt;添え字>)<r/>
</bq>
　指定された位置にある添え字を削除します。添え字以降の要素は一つずつ前にずれ、詰められます。添え字が範囲外の場合は例外が発生します。<r/>
</para>

<para>
<ptitle>remove</ptitle>
　remove メソッドは、指定された値と同じ値を持つ要素を削除します。<r/>
<bq>
構文 : remove(&lt;値>, &lt;すべて削除するか=true>)<r/>
</bq>
　指定された値と各要素を識別比較し ( <kw>===</kw> 演算子の動作 )、一致した要素を削除します。<r/>
　すべて削除するか、が false の場合は、最初に見つかった要素のみを削除します。そうでなければ、見つかったすべての要素を削除します。<r/>
</para>

<para>
<ptitle>insert</ptitle>
　insert メソッドは、指定された値を指定された位置に挿入します。<r/>
<bq>
構文 : insert(&lt;位置>, &lt;値>)<r/>
</bq>
　位置で示された添え字位置に、値で示された要素を挿入します。位置以降の要素は一つずつ後ろにずれます。<r/>
</para>

<para>
<ptitle>add</ptitle>
　add メソッドは、指定された値を配列の最後に追加します。<r/>
<bq>
構文 : add(&lt;値>)<r/>
</bq>
　配列の最後に値で示された要素を追加します。<r/>
　このメソッドは値が追加された位置を返します。<r/>
</para>

<para>
<ptitle>find</ptitle>
　find メソッドは、指定された値が最初に現れる添え字を返します。<r/>
<bq>
構文 : find(&lt;値>, &lt;検索開始位置=0>)<r/>
</bq>
　指定された値を、検索開始位置の添え字から順に見ていき、最初に現れる添え字を返します。指定された値が見つからなかったときは -1 を返します。<r/>
　比較には識別比較 ( === 演算子の動作 ) が用いられます。<r/>
</para>

<para>
<ptitle>push</ptitle>
　push メソッドは、指定された要素を配列の最後に追加します。<r/>
　addメソッドと違い、このメソッドは追加後の配列のサイズを返します。また、複数の引数を指定した場合は、すべての引数を順番に追加します。<r/>
<bq>
構文 : push(&lt;値>, ...)<r/>
</bq>
</para>

<para>
<ptitle>pop</ptitle>
　push メソッドは、配列の最後から一つ要素を取り出し、それを返します。取り出された要素は配列から削除されます(配列のサイズは一つ減ります)。<r/>
　このメソッドは、取り出された要素を返します。要素が無かった場合はvoidを返します。<r/>
<bq>
構文 : pop()<r/>
</bq>
</para>


<para>
<ptitle>unshift</ptitle>
　unshift メソッドは、要素を配列の先頭に追加します。複数の要素が指定された場合は複数の要素を先頭に追加することができます。この場合は、たとえば a, b, c の順番で渡された場合は、配列の先頭の要素は a, b, c の順番になります。<r/>
　このメソッドは追加後の配列のサイズを返します。<r/>
<bq>
構文 : unshift(&lt;値>, ...)<r/>
</bq>
</para>

<para>
<ptitle>shift</ptitle>
　shift メソッドは、配列の最初から一つ要素を取り出し、それを返します。取り出された要素は配列から削除されます(配列のサイズは一つ減ります)。<r/>
　このメソッドは、取り出された要素を返します。要素が無かった場合はvoidを返します。<r/>
<bq>
構文 : shift()<r/>
</bq>
</para>

<para>
<ptitle>pack</ptitle>
　pack メソッドは、引数で指定された文字列に従い、配列要素をバイナリ(Octet)化して返します。<r/>
　指定の文字列はテンプレートと呼びます。<r/>
　テンプレートは、型指定文字とその長さを並べたものです。長さとして * が指定された時は残り全ての長さを表します。長さが省略された場合は1として扱います。<r/>
<bq>
構文 : pack(テンプレート文字列)<r/>
</bq>
テンプレート文字列には以下の文字が使用可能です。<r/>
　a : ASCII 文字列(ヌル文字が補完される)<r/>
　A : ASCII 文字列(スペースが補完される)<r/>
　b : 2進数文字列(下位ビットから上位ビットの順)<r/>
　B : 2進数文字列(上位ビットから下位ビットの順)<r/>
　c : 符号付き1バイト数値(-128 縲鰀 127)<r/>
　C : 符号無し1バイト数値(0縲鰀255)<r/>
　d : 倍精度浮動小数点値<r/>
　f : 単精度浮動小数点値<r/>
　h : 16進数文字列(low nybble first)<r/>
　H : 16進数文字列(high nybble first)<r/>
　i : 符号付きint数値(通常4バイト)<r/>
　I : 符号無しint数値(通常4バイト)<r/>
　l : 符号付きlong数値(通常4バイト)<r/>
　L : 符号無しlong数値(通常4バイト)<r/>
　n : 符号無しshort数値(ネットワークバイトオーダ)<r/>
　N : 符号無しlong数値(ネットワークバイトオーダ)<r/>
　s : 符号付きshort数値(通常2バイト)<r/>
　S : 符号無しshort数値(通常2バイト)<r/>
　v : 符号無しshort値(リトルエンディアン)<r/>
　V : 符号無しlong値(リトルエンディアン)<r/>
　x : ヌル文字<r/>
　X : 1バイト後退<r/>
　@ : 絶対位置までヌル文字を埋める<r/>
　m : Base64 decode<r/>
<example>
	var oct = array.pack("a4i2");<r/>
</example>
　この例ではarrayの要素0番目の文字列を4文字をchar型で出力し、4文字に満たない場合は\0を追加します。<r/>
　その後要素1番縲鰀2番の整数を符号付き4バイト整数として追加します。<r/>
　つまり、char * 2 + int * 4 のバイナリ列として出力されます。<r/>
</para>

</doc>
