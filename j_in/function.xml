<?xml version="1.0" encoding="UTF-8" ?>
<doc>
<title>関数</title>

<para>
<ptitle>関数</ptitle>
　TJS2 の関数は<kw>サブルーチン</kw>とほぼ同義です。値を返すことのない場合も関数として扱います。<r/>
　また、特にクラスやオブジェクトのメンバとなっている関数を「<kw>メソッド</kw>」と呼ぶことがあります。<r/>
</para>

<para>
<ptitle>関数の書き方</ptitle>
　関数は、以下の書式で書くことができます。<r/>
<bq>
	function 関数名 ( 引数リスト )<r/>
	{<r/>
		関数の内容<r/>
	}<r/>
</bq>
<r/>
　まず、関数を定義するには、<kw>function</kw> を書きます。そのあとに、関数の名前を書きます。ここに書いた名前で関数が使用可能になります。<r/>
　関数の内容には、関数内で実行したいステートメントやブロックを記述することができます。<r/>
<r/>
<example>
	function test(a) { System.inform(a); }<r/>
	function func(a, b, c, d)<r/>
	{<r/>
		test(a);<r/>
		test(b);<r/>
		test(c);<r/>
		test(d);<r/>
		return a+b-c*d;<r/>
	}<r/>
</example>
<r/>
関数に対して instanceof 演算子を "Function" を伴って使用した場合は真になります(上記の例で言うと、func instanceof "Function" は真)。<r/>
</para>

<para>
<ptitle>関数の呼び出し</ptitle>
　関数の呼び出しは <kw>( )</kw> 演算子を使って、以下のように記述します。<r/>
<tt>
	関数名( 引数 )<r/>
</tt>
	引数がない場合は、<tt>関数名( )</tt> になります。引数には、式を指定し、複数ある場合はカンマで区切って指定します。<r/>
<example>
	func();<r/>
	func(1+2, 1-2);<r/>
	func(func2());<r/>
</example>
<r/>
	また、式を指定せずに、空にしておくと、そこの部分には void が指定されたと見なされます。<r/>
<example>
	func(,1); // void, 1 が指定されたとみなされる<r/>
	func(,); // void, void が指定されたと見なされる<r/>
</example>
</para>

<para>
<ptitle>引数リスト</ptitle>
　引数リストには、渡された引数を受け取るための変数の名前を書きます。関数呼び出しの際に渡した引数のうち、前に書いたものから順番に、変数に引き渡されます。<r/>
<example>
	function test(a, b, c)<r/>
	{<r/>
		// この時点で、 a と b と c という変数が使用可能であり、<r/>
		// 引数として渡された 3 つの引数が代入されています。<r/>
		// test(1, 2, 3) と呼び出した場合は、 a に 1、<r/>
		// b に 2, c に 3 が入っています。<r/>
	}<r/>
</example>
<r/>
　これらの引数はローカル変数であり、関数から実行が抜けるとアクセスできなくなります。<r/>
<r/>
　TJS2 では、関数呼び出しの際に与えられた引数が宣言の引数の数よりも少なかったり、多かったりしてもエラーにはなりません ( 例外的に、TJS2 で記述されたのではない関数 ( 実体が C++ などで記述された関数 ) はエラーにする場合があります )。与えられた引数が宣言より多い場合は多い分が無視され、少ない場合は、足りない変数には void が渡されます。<r/>
<example>
	function test(a, b)<r/>
	{<r/>
		// もし test(1) として呼び出すと、a には 1 、b には void が入る。<r/>
		// もし test(1,2,3) として呼び出すと、 a には 1、 b には 2 が入り、3 は無視される<r/>
	}<r/>
</example>
<r/>
　引数リストの個々の引数には、 = に続けてデフォルトの値 ( <kw>デフォルト引数</kw> ) を指定することができます。これは、void が指定されたときや、与えられた引数が宣言の引数に満たない場合に、自動的に指定された値が使用されるというものです。<r/>
<example>
	function test(a = -1, b = 1)<r/>
	{<r/>
		// もし・・・<r/>
		// test() として呼び出すと、 a=-1, b=1<r/>
		// test(5) として呼び出すと、 a=5, b=1<r/>
		// test(void,void) として呼び出すと、 a=-1, b=1<r/>
		// test(,4) として呼び出すと、a=-1, b=4<r/>
	}<r/>
</example>
<r/>
　引数を受け取る必要のない関数は、引数リストを省略することができます。<r/>
<example>
	function test<r/>
	{<r/>
		// 引数を受け取らない関数<r/>
	}<r/>
</example>
</para>

<para>
<ptitle>式中関数</ptitle>
　function キーワードを式内で使うと、名前のない関数、式中関数 ( <kw>匿名関数</kw> ) を作成することができます。<r/>
　この場合、関数の名前は省略します。<r/>
<example>
	var func = function(i) { return i*5; };<r/>
	var func2 = function { System.inform("hoge"); };<r/>
	var v = func(); // func 呼び出し<r/>
	func2(); // func2 呼び出し<r/>
</example>
</para>

<para>
<ptitle>引数の省略</ptitle>
　関数を呼び出す際に、 <kw>...</kw> のみを引数として書くと、呼び出す式を記述した関数に引き渡された引数が、そのまま関数呼び出し先の関数に引き渡されます。これは、引数変数の内容を変更していても、あるいは受け取った引数が足りなくても、正しい元の内容、引数の数がわたります。<r/>
<example>
	function test()<r/>
	{<r/>
		test2(...);<r/>
		// test2 には test に渡された引数が、渡された時点のまま<r/>
		// の内容、個数で渡される<r/>
	}<r/>
</example>
</para>

<para>
<ptitle>引数の配列変換</ptitle>
　引数を配列として受け取ることができます。配列として受け取るには、引数名に '<kw>*</kw>' を付けて関数を宣言します。<r/>
<example>
	function func(args*)<r/>
	{<r/>
		// args はこの関数に渡された引数を要素として持つ配列になる<r/>
		// たとえば func(1, 2, 3, 4) として呼び出された場合、<r/>
		// args には 4 つの要素が入っており、先頭から 1 2 3 4 の順で<r/>
		// 数値が入っていることになる。<r/>
	}<r/>
</example>
<r/>
　引数の途中から最後までを全て配列として受け取ることもできます。引数の数が満たなかった場合は、配列は空となります。<r/>
<example>
	function func(x, args*)<r/>
	{<r/>
		// たとえば func(1, 2, 3, 4) として呼び出された場合、<r/>
		// x には 1 が入る。また args には 3 つの要素が入っており、<r/>
		// 先頭から 2 3 4 の順で数値が入っていることになる。<r/>
		// func(1) として呼び出された場合、引数の数が満たないため、<r/>
		// args は要素のない配列となる。<r/>
	}<r/>
</example>
　これは、可変長の引数を処理したい場合に便利です。<r/>
<r/>
　引数名を指定しない事も可能です。この場合は、後述の配列の引数への展開の際に、名前なしの * として使用できます。<r/>
</para>

<para>
<ptitle>配列の引数への展開</ptitle>
　配列を展開し、引数として関数に渡すことができます。この場合は、引数の配列展開の際と同じく、展開したい式の後ろに '<kw>*</kw>' を付けて関数を呼び出します。'*' を指定して展開したい式は、配列を表して無ければなりません。<r/>
<example>
	var args = [1, 2, 3, 4];<r/>
	func(args*);<r/>
	// args には 1 2 3 4 の4つの要素が入っているため、<r/>
	// func(1, 2, 3, 4); と同じ意味になる。<r/>
	func(0, args*, 5);<r/>
	// このように引数の途中に挟むことも可能。<r/>
	// この場合は、func(0, 1, 2, 3, 4, 5); と同じ意味に<r/>
	// なる。<r/>
</example>
<r/>
　式を指定せずに、単に * を引数に指定すると、呼び出す式を記述した関数の宣言時に書いた名前のない '*' が表す引数を、そのまま呼び出し先に渡すことができます。
<example>
	function func(func_array, *)<r/>
	{<r/>
		// func_array で指定された関数に、<r/>
		// その関数の func_array 内の位置につづき、<r/>
		// func に渡された 2 番目以降の引数を<r/>
		// そのまま引き渡して呼び出す<r/>
		for(var i = 0; i &lt; func_array.count; i++)<r/>
			func_array[i](i, *);<r/>
	}<r/>
</example>
<r/>
　名前の無い * による関数呼び出し処理は、名前のある配列を使うよりも効率よく処理できます。<r/>
<example>
	function func(ar*) { func2(ar*); }<r/>
	function func(*) { func2(*); }<r/>
	// 上記の二つは全く同じ意味になるが、下の例の方が効率がよい<r/>
</example>
<r/>
　名前の無い * は、「引数の省略」と同様の効果を持ちます。以下の二つの関数宣言は同じ意味になります。<r/>
<example>
	function func() { func2(...); }<r/>
	function func(*) { func2(*); }<r/>
</example>
</para>

</doc>
