<?xml version="1.0" encoding="UTF-8" ?>
<doc>
<title>プロパティ</title>

<para>
<ptitle>プロパティ</ptitle>
　プロパティとは、変数と同じように扱うことができるが、実際はメソッド呼び出しと同様に、<kw>セッター</kw> ( <kw>setter</kw> ) と<kw>ゲッター</kw> ( <kw>getter</kw> ) の呼び出しを伴うものです。セッターやゲッターを、プロパティハンドラと呼ぶ場合があります。<r/>
<r/>
　構文は以下の通りです。<r/>
<bq>
<kw>property</kw> 識別子<r/>
{<r/>
	setter(引数)<r/>
	{<r/>
		// ここにセッターの内容<r/>
	}<r/>
<r/>
	getter()<r/>
	{<r/>
		// ここにゲッターの内容<r/>
		return 式; // ゲッターとして返す値<r/>
	}<r/>
}<r/>
</bq>
　setter と getter は、逆の順番で書かれていてもかまいません。 <r/>
　この property を記述したクラスや、グローバルのメンバとしてこのプロパティは登録されますが、この識別子からの値の取得はゲッター、値の設定はセッターを通して行われます。これらのセッターとゲッターは、メソッド同様に様々な内容を書くことができます。セッターは setter に続く ( ) 内に、値を受け取る変数を引数として書きます。ゲッターは <kw>return</kw> ステートメントにて値を返します。<r/>
<r/>
　getterのあとの () は省略できます。 <r/>
<r/>
　一つの識別子に対し、セッターとゲッターの両方を書けば、読み書きの両方が可能なプロパティになります。一方しか書かない場合、たとえばゲッターしか書かない場合は、読み出し専用のプロパティとなり、書き込みはエラーになります。<r/>
<example>
	var value;<r/>
<r/>
	property property1 // プロパティ 'property1' を宣言<r/>
	{<r/>
		setter(v)<r/>
		{<r/>
			// セッターはただ一つだけの引数をとる<r/>
			value=v; // 引数 v を処理する<r/>
<r/>
			inform("value set.");<r/>
		}<r/>
<r/>
		getter<r/>
		{<r/>
			// propset と同じ識別子 'property1' のゲッターを宣言<r/>
			// ゲッターに引数はない<r/>
			inform("value get.");<r/>
			return value; // 戻り値として返す<r/>
		}<r/>
	}<r/>
<r/>
	property1=5; // property1 への代入は、セッターが呼ばれる<r/>
	property1++; // このような式では、ゲッターが呼ばれ、<r/>
	             // 次にセッターが呼ばれて値が設定される<r/>
}<r/>
</example>
　プロパティも変数や関数やクラス同様、<kw>オーバーライド</kw>できます。<r/>
</para>

<para>
<ptitle>プロパティオブジェクト</ptitle>
　プロパティ自身も一つのオブジェクトです。しかし、なんらかのオブジェクトに登録されている場合は、普通のアクセス方法ではプロパティハンドラが呼ばれるだけであり、プロパティオブジェクトそのものにはアクセスできません。<r/>
　プロパティオブジェクトそのものを取り出すには <tt><kw>&amp;</kw></tt> 演算子を使います。取り出したプロパティオブジェクトはローカル変数に入れることが出来ます。<r/>
　また、<tt>&amp;</tt> 演算子を使ってプロパティオブジェクトを登録することもできます。<r/>
<example>
	property prop // プロパティ prop を宣言<r/>
	{<r/>
		(略)<r/>
	}<r/>
<r/>
{<r/>
	var p = &amp;prop; // プロパティオブジェクトを得てローカル変数に入れる<r/>
<r/>
	&amp;object.property1 = p; // p を object の property1 として登録する<r/>
}<r/>
</example>
<r/>
　<tt>&amp;</tt> 演算子を使うと、ゲッターやセッターは呼ばれずにプロパティオブジェクトそのものにアクセスする事ができます。<tt>&amp;</tt> 演算子を使わなければ通常のプロパティへのアクセスとなります。<r/>
<r/>
　ローカル変数として取り出したプロパティオブジェクトは、オブジェクトに登録しなくとも、<tt><kw>*</kw></tt> 演算子を用いてプロパティハンドラを呼び出すことができます。<r/>
<r/>
<example>
	property prop // プロパティ prop を宣言<r/>
	{<r/>
		(略)<r/>
	}<r/>
<r/>
{<r/>
	var p = &amp;prop; // プロパティオブジェクトを得てローカル変数に入れる<r/>
<r/>
	*p = 30; // setter を呼び出し 30 を設定する<r/>
	func(*p); // getter を呼び出し値を取得し、func に渡す<r/>
}<r/>
</example>
<note>
上記のように var 変数にプロパティオブジェクトをとる場合は、変数はローカル変数にしてください。これは、プロパティオブジェクトはいったんオブジェクトに登録されると、プロパティオブジェクトとしてではなくプロパティとしてゲッターやセッターを介した動作をするようになるためです。つまり、ローカル変数ではなく、グローバル変数(＝globalのメンバ)やオブジェクトのメンバにプロパティオブジェクトを登録してしまうと、普通のプロパティと同じように振る舞うようになります。もちろんこのようにしてグローバル変数やオブジェクトのメンバに登録したプロパティオブジェクトを取り出すために &amp; 演算子を使うのはかまいません。
</note>
<r/>
プロパティオブジェクトに対して instanceof 演算子を "Property" を伴って使用した場合は真になります(上記の例で言うと、&amp;prop instanceof "Property" は真)。<r/>
</para>
</doc>
